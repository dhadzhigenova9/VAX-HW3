<!DOCTYPE html>
<html lang="bg">
<head>
<meta charset="utf-8">
<title>Gyro Look – стабилен режим</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
    body {
        margin: 0;
        overflow: hidden;
        background: #000;
    }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
let scene, camera, cameraParent, renderer;

let targetPitch = 0;
let targetYaw = 0;
let currentPitch = 0;
let currentYaw = 0;

let lastAlpha = null;
let accumulatedYaw = 0;

// Калибрация
let betaOffset = null;

const LERP = 0.15;
const MAX_PITCH = THREE.MathUtils.degToRad(80);

init();
animate();

function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    camera.rotation.order = 'YXZ';

    cameraParent = new THREE.Object3D();
    cameraParent.add(camera);
    scene.add(cameraParent);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(5, 10, 7);
    scene.add(light);

    const room = new THREE.Mesh(
        new THREE.BoxGeometry(30, 15, 30),
        new THREE.MeshLambertMaterial({
            color: 0x1faa3a,
            side: THREE.BackSide
        })
    );
    scene.add(room);

    const coneGeo = new THREE.ConeGeometry(0.35, 1.2, 24);
    coneGeo.translate(0, 0.6, 0);

    for (let i = 0; i < 80; i++) {
        const mat = new THREE.MeshLambertMaterial({
            color: Math.random() * 0xffffff
        });
        const c1 = new THREE.Mesh(coneGeo, mat);
        c1.position.set(
            Math.random() * 28 - 14,
            -7.5,
            Math.random() * 28 - 14
        );
        scene.add(c1);

        const c2 = c1.clone();
        c2.position.y = 7.5;
        c2.rotation.x = Math.PI;
        scene.add(c2);
    }

    window.addEventListener('resize', onResize);
    window.addEventListener('deviceorientation', onOrientation, true);
}

function onOrientation(e) {
    if (e.alpha === null || e.beta === null) return;

    // ---------- YAW (alpha) ----------
    if (lastAlpha !== null) {
        let delta = e.alpha - lastAlpha;
        if (delta > 180) delta -= 360;
        if (delta < -180) delta += 360;
        accumulatedYaw += delta;
    }
    lastAlpha = e.alpha;
    targetYaw = THREE.MathUtils.degToRad(accumulatedYaw);

    // ---------- PITCH (beta – стабилната ос) ----------
    if (betaOffset === null) {
        betaOffset = e.beta; // гледам напред
    }

    let pitchDeg = e.beta - betaOffset;
    pitchDeg = THREE.MathUtils.clamp(pitchDeg, -80, 80);
    targetPitch = THREE.MathUtils.degToRad(pitchDeg);
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);

    currentPitch += (targetPitch - currentPitch) * LERP;
    currentYaw += (targetYaw - currentYaw) * LERP;

    camera.rotation.x = currentPitch;
    cameraParent.rotation.y = currentYaw;

    renderer.render(scene, camera);
}
</script>

</body>
</html>
