<!DOCTYPE html>
<html lang="bg">
<head>
<meta charset="utf-8">
<title>Оглеждане в стая – стабилен gyro контрол</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
    body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: sans-serif;
    }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
let scene, camera, cameraParent, renderer;

// Целеви и текущи ъгли
let targetPitch = 0;
let targetYaw = 0;
let currentPitch = 0;
let currentYaw = 0;

// За yaw натрупване
let lastAlpha = null;
let accumulatedYaw = 0;

const LERP = 0.12;
const MAX_PITCH = THREE.MathUtils.degToRad(85);

init();
animate();

function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );

    // ВАЖНО
    camera.rotation.order = 'YXZ';

    cameraParent = new THREE.Object3D();
    cameraParent.add(camera);
    scene.add(cameraParent);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Светлини
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(5, 10, 7);
    scene.add(light);

    // Стая
    const room = new THREE.Mesh(
        new THREE.BoxGeometry(30, 15, 30),
        new THREE.MeshLambertMaterial({
            color: 0x1faa3a,
            side: THREE.BackSide
        })
    );
    scene.add(room);

    // Конуси
    const coneGeo = new THREE.ConeGeometry(0.35, 1.2, 24);
    coneGeo.translate(0, 0.6, 0);

    for (let i = 0; i < 80; i++) {
        const mat = new THREE.MeshLambertMaterial({
            color: Math.random() * 0xffffff
        });

        const c1 = new THREE.Mesh(coneGeo, mat);
        c1.position.set(
            Math.random() * 28 - 14,
            -7.5,
            Math.random() * 28 - 14
        );
        scene.add(c1);

        const c2 = c1.clone();
        c2.position.y = 7.5;
        c2.rotation.x = Math.PI;
        scene.add(c2);
    }

    window.addEventListener('resize', onResize);
    window.addEventListener('deviceorientation', onOrientation, true);
}

function onOrientation(e) {
    if (e.alpha === null) return;

    // ---------- YAW ----------
    let alpha = e.alpha;

    if (lastAlpha !== null) {
        let delta = alpha - lastAlpha;
        if (delta > 180) delta -= 360;
        if (delta < -180) delta += 360;
        accumulatedYaw += delta;
    }
    lastAlpha = alpha;

    targetYaw = THREE.MathUtils.degToRad(accumulatedYaw);

    // ---------- PITCH ----------
    let pitchDeg = 0;

    let screenAngle = 0;
    if (screen.orientation && screen.orientation.angle !== undefined) {
        screenAngle = screen.orientation.angle;
    } else if (window.orientation !== undefined) {
        screenAngle = window.orientation;
    }

    switch (screenAngle) {
        case 0:       // Portrait
            pitchDeg = e.beta;
            break;

        case 90:      // Landscape Left
            pitchDeg = -e.gamma;
            break;

        case -90:
        case 270:     // Landscape Right
            pitchDeg = e.gamma;
            break;
    }

    pitchDeg = THREE.MathUtils.clamp(pitchDeg, -85, 85);
    targetPitch = THREE.MathUtils.degToRad(pitchDeg);
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);

    // Плавно движение
    currentPitch += (targetPitch - currentPitch) * LERP;
    currentYaw += (targetYaw - currentYaw) * LERP;

    camera.rotation.x = currentPitch;
    cameraParent.rotation.y = currentYaw;

    renderer.render(scene, camera);
}
</script>

</body>
</html>
